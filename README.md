### Идея решения:
1. Т.к. приложение делается для конкретного зоопарка, для класса `Zoo` нет интерфейса/абстрактного класса
2. Для поддержания тестируемости и возможности дальнейшего расширения созданы следующие интерфейсы (domain/contract):
`Alive`, `ConsoleAgent`, `Inventory`, `ReportBuilder`, `VetClinic`
3. Создан `InventoryValueHolder` который отвечает за работу с инвентарным номером объектов (автоинкрементирует их)
4. Под каждый пункт тз реализован отдельный пункт в меню. Само меню и страницы, на которые пользователь переходит, вводя число - отдельные классы, наследники абстрактного класса `Page` с методами **render** и **finishRendering**
5. За отрисовку страниц отвечает `DefaultPageRenderer`, который на вход получает мапу, где ключ - KClass страницы (работает на рефлексии), а значение - объект класса страницы (который получается из DI контейнера). В себе он хранит текущий стек страниц
6. Навигация по страницами происходит посредством возврата наследника `FinishRenderResult` из метода finishRendering у страниц.
7. DI контейнер генерируется согласно правилам описанным в директории di фреймворком Dagger (в папке build можно посмотреть сгенерированный код)
8. Есть базовые классы `Animal`, `Thing` и тп для доменных моделей
9. К сожалению в Java/Kotlin нет удобного апи для работы с консолью (даже очистить нельзя), поэтому сделал настолько красиво, насколько это возможно

### Применение SOLID
1. SRP - каждый класс имеет лишь одну причину для изменения: для этого в отдельные классы была вынесена логика по работе с консолью и по генерации репортов. Система классов - наследников `Page` также была создана для того, чтобы не пихать все в одно место
2. OCP - все есть абстракция. Классы Page зависят от интерфейсов `ReportBuilder` и `ConsoleAgent`, что позволяет в будущем подменить, например формат создания репортов на другой, не изменяя при этом сами странички. `Zoo` зависит от интерфейса `VetClinic` что дает возможность подменить вет клинику на другую, у которой будут другие правила проверки животных
3. LSP - здесь сказать особо нечего, потому что используется наследование только от абстрактных классов и интерфейсов, поэтому данный принцип соблюдается
4. ISP - Существует разделение на `Alive` и `Inventory` что позволяет существовать неживым инвентаризуемым объектам.
5. DIP - Зависимости (исключение - у Zoo нет абстракции) направлены в сторону абстракций. Например, классы `Page` зависят от интерфейса `ConsoleAgent` а не от `DefaultConsoleAgent`. Еще один пример - `Zoo` зависит от интерфейса `VetClinic` а не реализации `VetClinicImpl`

### Инструкция по запуску программы и тестов
1. Установить среду разработки IntelliJIdea
2. Склонировать репозиторий себе в папку с проектами (main или dev ветка)
3. Собрать проект (кнопка в IDEA либо ./gradlew build в консоли в папке проекта), чтобы фреймворк по предоставлению зависимостей смог все сгенерировать
4. Запустить MainKt файл (легче всего через кнопку в IDEA)
5. Для запуска тестов остановите выполнение программы и в консоль в папке проекта нужно прописать ./gradlew test
6. К сожалению легкого способа для оценки покрытия кода тестами я не нашел, но покрыты все классы страниц, вет клиника и зоопарк (тесты лежат в модуле `test`)


## Спасибо за внимание!
#### P.S. если что можно написать мне в тг @arifruette если что-то не получилось запустить или есть вопросы по реализации